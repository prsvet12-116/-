<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–õ–∞–±–∏—Ä–∏–Ω—Ç –¢—å–º—ã - –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }
        
        body {
            background: #000;
            color: #e0e0e0;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
        }
        
        #game-canvas {
            display: block;
            background: #000;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.85);
            border-radius: 8px;
            border: 1px solid #333;
            backdrop-filter: blur(5px);
            min-width: 200px;
        }
        
        .ui-element {
            margin: 12px 0;
            display: flex;
            align-items: center;
            font-size: 14px;
        }
        
        .crystal-icon {
            width: 16px;
            height: 16px;
            background: linear-gradient(45deg, #00ffff, #0088ff);
            border-radius: 50%;
            margin-right: 8px;
            box-shadow: 0 0 8px #00ffff;
            animation: pulse 2s infinite;
        }
        
        .key-icon {
            width: 20px;
            height: 12px;
            background: linear-gradient(to right, #ffaa00, #ff8800);
            margin-right: 8px;
            border-radius: 3px;
            box-shadow: 0 0 6px #ffaa00;
        }
        
        .heart-icon {
            color: #ff5555;
            margin: 0 3px;
            font-size: 16px;
            text-shadow: 0 0 5px #ff0000;
        }
        
        #menu-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, #1a1a2e 0%, #0a0a0a 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            padding: 20px;
        }
        
        .title {
            font-size: 3.5rem;
            color: #00ffff;
            text-shadow: 0 0 15px #00ffff, 0 0 30px #0088ff;
            margin-bottom: 30px;
            letter-spacing: 4px;
            text-align: center;
            animation: titleGlow 3s infinite alternate;
        }
        
        .menu-button {
            background: rgba(34, 34, 34, 0.8);
            color: #00ffff;
            border: 2px solid #00ffff;
            padding: 12px 30px;
            margin: 10px;
            font-size: 1.1rem;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.3s;
            min-width: 180px;
            text-align: center;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
            backdrop-filter: blur(5px);
        }
        
        .menu-button:hover {
            background: rgba(0, 255, 255, 0.2);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.7);
            transform: translateY(-2px);
        }
        
        .developer {
            position: absolute;
            bottom: 20px;
            color: #666;
            font-size: 0.8rem;
        }
        
        #game-screen {
            display: none;
            width: 100%;
            height: 100%;
        }
        
        #level-complete {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 30px;
            border-radius: 10px;
            border: 2px solid #00ff00;
            text-align: center;
            display: none;
            z-index: 50;
            backdrop-filter: blur(10px);
            min-width: 300px;
        }
        
        .glowing-text {
            color: #00ff00;
            text-shadow: 0 0 10px #00ff00;
            margin-bottom: 15px;
            font-size: 1.5rem;
        }
        
        #debug-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            color: #0f0;
            display: none;
        }
        
        @keyframes pulse {
            0% { opacity: 0.7; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.1); }
            100% { opacity: 0.7; transform: scale(1); }
        }
        
        @keyframes titleGlow {
            0% { text-shadow: 0 0 15px #00ffff, 0 0 30px #0088ff; }
            100% { text-shadow: 0 0 20px #00ffff, 0 0 40px #0088ff, 0 0 60px #0088ff; }
        }
        
        @media (max-width: 768px) {
            .title { font-size: 2.5rem; }
            #ui { 
                top: 10px; 
                left: 10px; 
                padding: 10px;
                font-size: 12px;
            }
            .menu-button { 
                padding: 10px 20px; 
                min-width: 150px; 
                font-size: 1rem;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="menu-screen">
            <h1 class="title">–õ–ê–ë–ò–†–ò–ù–¢ –¢–¨–ú–´</h1>
            <p style="color: #888; margin-bottom: 40px; text-align: center; max-width: 600px;">
                –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è - –±–µ—Å–ø—Ä–µ—Ä—ã–≤–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ
            </p>
            <div id="menu-buttons">
                <div class="menu-button" onclick="startGame()">–ù–ê–ß–ê–¢–¨ –ò–ì–†–£</div>
                <div class="menu-button" onclick="toggleDebug()">–í–ö–õ/–í–´–ö–õ –î–ï–ë–ê–ì</div>
            </div>
            <div class="developer">–†–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫: –ü—Ä–æ—Å–≤–µ—Ç–æ–≤ –°–µ—Ä–≥–µ–π –ù–∏–∫–æ–ª–∞–µ–≤–∏—á</div>
        </div>
        
        <div id="game-screen">
            <canvas id="game-canvas"></canvas>
            <div id="ui">
                <div class="ui-element">
                    <div>–£—Ä–æ–≤–µ–Ω—å: <span id="current-level">1</span>/5</div>
                </div>
                <div class="ui-element">
                    <div class="crystal-icon"></div>
                    <div>–ö—Ä–∏—Å—Ç–∞–ª–ª—ã: <span id="crystals">0</span>/<span id="total-crystals">3</span></div>
                </div>
                <div class="ui-element">
                    <div class="key-icon"></div>
                    <div>–ö–ª—é—á: <span id="key-status">–ù–ï–¢</span></div>
                </div>
                <div class="ui-element">
                    <div>–ñ–∏–∑–Ω–∏: <span id="hearts">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</span></div>
                </div>
                <div class="menu-button" onclick="returnToMenu()" style="margin: 10px 0 0 0; padding: 8px; font-size: 0.9rem;">
                    –í –ú–ï–ù–Æ
                </div>
            </div>
            
            <div id="debug-info">
                <div>–ü–æ–∑–∏—Ü–∏—è: <span id="debug-pos">0,0</span></div>
                <div>–¶–µ–ª—å: <span id="debug-target">0,0</span></div>
                <div>–î–≤–∏–∂–µ–Ω–∏–µ: <span id="debug-moving">–Ω–µ—Ç</span></div>
                <div>–ö–ª–µ—Ç–∫–∞: <span id="debug-cell">1,1</span></div>
            </div>
        </div>
        
        <div id="level-complete">
            <h2 class="glowing-text">–£–†–û–í–ï–ù–¨ –ü–†–û–ô–î–ï–ù!</h2>
            <p>–í—Å–µ –∫—Ä–∏—Å—Ç–∞–ª–ª—ã —Å–æ–±—Ä–∞–Ω—ã</p>
            <p>–î–≤–µ—Ä—å –æ—Ç–∫—Ä—ã—Ç–∞</p>
            <div class="menu-button" onclick="nextLevel()">–°–õ–ï–î–£–Æ–©–ò–ô –£–†–û–í–ï–ù–¨</div>
        </div>
    </div>

    <script>
        // ================= –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø =================
        const CONFIG = {
            CELL_SIZE: 40,
            MAZE_WIDTH: 21,  // –î–æ–ª–∂–Ω–æ –±—ã—Ç—å –Ω–µ—á–µ—Ç–Ω—ã–º
            MAZE_HEIGHT: 21, // –î–æ–ª–∂–Ω–æ –±—ã—Ç—å –Ω–µ—á–µ—Ç–Ω—ã–º
            PLAYER_SPEED: 0.2, // –£–≤–µ–ª–∏—á–∏–ª–∏ —Å–∫–æ—Ä–æ—Å—Ç—å
            DEBUG_MODE: false
        };

        // ================= –ü–ï–†–ï–ú–ï–ù–ù–´–ï –ò–ì–†–´ =================
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        
        let gameState = 'menu';
        let currentLevel = 1;
        let crystalsCollected = 0;
        let totalCrystals = 3;
        let hasKey = false;
        let playerLives = 3;
        let maze = [];
        let player = { 
            x: 1, 
            y: 1, 
            gridX: 1, 
            gridY: 1,
            isMoving: false,
            moveQueue: null,
            moveProgress: 0
        };
        let crystals = [];
        let key = { x: 0, y: 0, collected: false };
        let door = { x: 0, y: 0, open: false };
        let spirits = [];
        let keysPressed = {};
        let lastTime = 0;

        // ================= –£–ü–†–û–©–ï–ù–ù–´–ô –ê–õ–ì–û–†–ò–¢–ú –ü–†–ò–ú–ê =================
        function generateMazePrim(width, height) {
            // –°–æ–∑–¥–∞–µ–º —Å–µ—Ç–∫—É (1 - —Å—Ç–µ–Ω–∞, 0 - –ø—Ä–æ—Ö–æ–¥)
            const maze = Array(height).fill().map(() => Array(width).fill(1));
            
            // –ù–∞—á–∞–ª—å–Ω–∞—è —Ç–æ—á–∫–∞ (–≤—Å–µ–≥–¥–∞ –Ω–µ—á–µ—Ç–Ω—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã)
            const startX = 1;
            const startY = 1;
            maze[startY][startX] = 0;
            
            // –°–ø–∏—Å–æ–∫ –≥—Ä–∞–Ω–∏—á–Ω—ã—Ö —Å—Ç–µ–Ω
            let walls = [];
            
            // –î–æ–±–∞–≤–ª—è–µ–º –Ω–∞—á–∞–ª—å–Ω—ã–µ —Å—Ç–µ–Ω—ã
            const initialWalls = [
                {x: startX, y: startY - 1, fromX: startX, fromY: startY},
                {x: startX, y: startY + 1, fromX: startX, fromY: startY},
                {x: startX - 1, y: startY, fromX: startX, fromY: startY},
                {x: startX + 1, y: startY, fromX: startX, fromY: startY}
            ].filter(wall => 
                wall.x > 0 && wall.x < width - 1 && 
                wall.y > 0 && wall.y < height - 1
            );
            
            walls.push(...initialWalls);
            
            while (walls.length > 0) {
                // –í—ã–±–∏—Ä–∞–µ–º —Å–ª—É—á–∞–π–Ω—É—é —Å—Ç–µ–Ω—É
                const randomIndex = Math.floor(Math.random() * walls.length);
                const wall = walls[randomIndex];
                walls.splice(randomIndex, 1);
                
                // –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –∫–ª–µ—Ç–∫–∏ –∑–∞ —Å—Ç–µ–Ω–æ–π
                const toX = wall.x + (wall.x - wall.fromX);
                const toY = wall.y + (wall.y - wall.fromY);
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∫–ª–µ—Ç–∫–∞ –≤–Ω—É—Ç—Ä–∏ –ª–∞–±–∏—Ä–∏–Ω—Ç–∞
                if (toX > 0 && toX < width - 1 && 
                    toY > 0 && toY < height - 1) {
                    
                    // –ï—Å–ª–∏ –∫–ª–µ—Ç–∫–∞ –∑–∞ —Å—Ç–µ–Ω–æ–π –µ—â–µ —Å—Ç–µ–Ω–∞
                    if (maze[toY][toX] === 1) {
                        // –û—Ç–∫—Ä—ã–≤–∞–µ–º —Å—Ç–µ–Ω—É –∏ –∫–ª–µ—Ç–∫—É
                        maze[wall.y][wall.x] = 0;
                        maze[toY][toX] = 0;
                        
                        // –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–µ —Å—Ç–µ–Ω—ã –≤–æ–∫—Ä—É–≥ –Ω–æ–≤–æ–π –∫–ª–µ—Ç–∫–∏
                        const newWalls = [
                            {x: toX, y: toY - 1, fromX: toX, fromY: toY},
                            {x: toX, y: toY + 1, fromX: toX, fromY: toY},
                            {x: toX - 1, y: toY, fromX: toX, fromY: toY},
                            {x: toX + 1, y: toY, fromX: toX, fromY: toY}
                        ].filter(newWall => 
                            newWall.x > 0 && newWall.x < width - 1 && 
                            newWall.y > 0 && newWall.y < height - 1 &&
                            maze[newWall.y][newWall.x] === 1
                        );
                        
                        walls.push(...newWalls);
                    }
                }
            }
            
            // –ì–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ–º, —á—Ç–æ –≤—ã—Ö–æ–¥ –¥–æ—Å—Ç–∏–∂–∏–º
            const exitX = width - 2;
            const exitY = height - 2;
            maze[exitY][exitX] = 0;
            
            // –ì–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å –æ—Å–Ω–æ–≤–Ω—ã–º –ª–∞–±–∏—Ä–∏–Ω—Ç–æ–º
            for (let y = exitY - 1; y <= exitY + 1; y++) {
                for (let x = exitX - 1; x <= exitX + 1; x++) {
                    if (x > 0 && x < width - 1 && y > 0 && y < height - 1) {
                        if (maze[y][x] === 0 && 
                            (x === exitX || y === exitY) &&
                            !(x === exitX && y === exitY)) {
                            maze[exitY][exitX] = 0;
                        }
                    }
                }
            }
            
            return maze;
        }

        // ================= –ì–ï–ù–ï–†–ê–¶–ò–Ø –£–†–û–í–ù–Ø =================
        function generateLevel(level) {
            console.log(`–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —É—Ä–æ–≤–Ω—è ${level}...`);
            
            // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ª–∞–±–∏—Ä–∏–Ω—Ç–∞
            maze = generateMazePrim(CONFIG.MAZE_WIDTH, CONFIG.MAZE_HEIGHT);
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–æ—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –ª–∞–±–∏—Ä–∏–Ω—Ç–∞
            if (!isMazePassable(maze)) {
                console.warn("–õ–∞–±–∏—Ä–∏–Ω—Ç –Ω–µ–ø—Ä–æ—Ö–æ–¥–∏–º, –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∑–∞–Ω–æ–≤–æ");
                return generateLevel(level); // –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∑–∞–Ω–æ–≤–æ
            }
            
            // –°–±—Ä–æ—Å –æ–±—ä–µ–∫—Ç–æ–≤
            crystals = [];
            spirits = [];
            
            // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —É—Ä–æ–≤–Ω—è
            totalCrystals = Math.min(3 + level - 1, 5);
            const spiritCount = Math.min(2 + level - 1, 6);
            
            // –ü–æ–∑–∏—Ü–∏—è –∏–≥—Ä–æ–∫–∞ (–≤—Å–µ–≥–¥–∞ –≤ –Ω–∞—á–∞–ª–µ)
            player.gridX = 1;
            player.gridY = 1;
            player.x = 1;
            player.y = 1;
            player.isMoving = false;
            player.moveQueue = null;
            player.moveProgress = 0;
            
            // –°–æ–±–∏—Ä–∞–µ–º –≤—Å–µ –¥–æ—Å—Ç—É–ø–Ω—ã–µ –∫–ª–µ—Ç–∫–∏
            const availableCells = [];
            for (let y = 0; y < maze.length; y++) {
                for (let x = 0; x < maze[y].length; x++) {
                    if (maze[y][x] === 0 && 
                        !(x === 1 && y === 1) && // –ù–µ —Å—Ç–∞—Ä—Ç–æ–≤–∞—è –ø–æ–∑–∏—Ü–∏—è
                        Math.abs(x - 1) + Math.abs(y - 1) > 5) { // –ù–µ —Å–ª–∏—à–∫–æ–º –±–ª–∏–∑–∫–æ –∫ —Å—Ç–∞—Ä—Ç—É
                        availableCells.push({ x, y });
                    }
                }
            }
            
            // –ü–µ—Ä–µ–º–µ—à–∏–≤–∞–µ–º –∫–ª–µ—Ç–∫–∏
            shuffleArray(availableCells);
            
            // –†–∞–∑–º–µ—â–∞–µ–º –∫—Ä–∏—Å—Ç–∞–ª–ª—ã
            for (let i = 0; i < totalCrystals && availableCells.length > 0; i++) {
                const cell = availableCells.pop();
                crystals.push({
                    x: cell.x,
                    y: cell.y,
                    collected: false,
                    pulse: Math.random() * Math.PI * 2
                });
            }
            
            // –†–∞–∑–º–µ—â–∞–µ–º –∫–ª—é—á
            if (availableCells.length > 0) {
                const keyCell = availableCells.pop();
                key = {
                    x: keyCell.x,
                    y: keyCell.y,
                    collected: false
                };
            }
            
            // –†–∞–∑–º–µ—â–∞–µ–º –¥–≤–µ—Ä—å (–≤ –ø—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–Ω–æ–º —É–≥–ª—É)
            door = {
                x: CONFIG.MAZE_WIDTH - 2,
                y: CONFIG.MAZE_HEIGHT - 2,
                open: false
            };
            
            // –†–∞–∑–º–µ—â–∞–µ–º –¥—É—Ö–æ–≤ (–ø–æ–¥–∞–ª—å—à–µ –æ—Ç –∏–≥—Ä–æ–∫–∞)
            for (let i = 0; i < spiritCount && availableCells.length > 0; i++) {
                const cell = availableCells.pop();
                spirits.push({
                    x: cell.x,
                    y: cell.y,
                    gridX: cell.x,
                    gridY: cell.y,
                    targetX: cell.x,
                    targetY: cell.y,
                    speed: 0.02 + (level * 0.01),
                    phase: Math.random() * Math.PI * 2,
                    moveCooldown: 0
                });
            }
            
            // –°–±—Ä–æ—Å —Å–æ—Å—Ç–æ—è–Ω–∏–π
            crystalsCollected = 0;
            hasKey = false;
            door.open = false;
            
            console.log(`–£—Ä–æ–≤–µ–Ω—å ${level} —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω. –ö—Ä–∏—Å—Ç–∞–ª–ª–æ–≤: ${totalCrystals}, –î—É—Ö–æ–≤: ${spiritCount}`);
        }

        // ================= –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò =================
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function isMazePassable(maze) {
            // –ü—Ä–æ—Å—Ç–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø—Ä–æ—Ö–æ–¥–∏–º–æ—Å—Ç—å (DFS –æ—Ç —Å—Ç–∞—Ä—Ç–∞ –∫ –≤—ã—Ö–æ–¥—É)
            const width = maze[0].length;
            const height = maze.length;
            const visited = Array(height).fill().map(() => Array(width).fill(false));
            const stack = [{x: 1, y: 1}];
            
            while (stack.length > 0) {
                const {x, y} = stack.pop();
                
                if (x === width - 2 && y === height - 2) {
                    return true; // –ù–∞—à–ª–∏ –ø—É—Ç—å –∫ –≤—ã—Ö–æ–¥—É
                }
                
                if (x < 0 || x >= width || y < 0 || y >= height || 
                    maze[y][x] === 1 || visited[y][x]) {
                    continue;
                }
                
                visited[y][x] = true;
                
                // –î–æ–±–∞–≤–ª—è–µ–º —Å–æ—Å–µ–¥–Ω–∏–µ –∫–ª–µ—Ç–∫–∏
                stack.push(
                    {x: x + 1, y},
                    {x: x - 1, y},
                    {x, y: y + 1},
                    {x, y: y - 1}
                );
            }
            
            return false;
        }

        function canMoveTo(x, y) {
            return (
                x >= 0 && x < CONFIG.MAZE_WIDTH &&
                y >= 0 && y < CONFIG.MAZE_HEIGHT &&
                maze[y][x] === 0
            );
        }

        // ================= –û–ë–ù–û–í–õ–ï–ù–ò–ï –ò–ì–†–´ =================
        function update(deltaTime) {
            if (gameState !== 'playing') return;
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–≥—Ä–æ–∫–∞
            updatePlayer(deltaTime);
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥—É—Ö–æ–≤
            updateSpirits(deltaTime);
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π
            checkCollisions();
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–µ–±–∞–≥-–∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏
            if (CONFIG.DEBUG_MODE) {
                updateDebugInfo();
            }
        }

        function updatePlayer(deltaTime) {
            // –û–±—Ä–∞–±–æ—Ç–∫–∞ –¥–≤–∏–∂–µ–Ω–∏—è –∏–∑ –æ—á–µ—Ä–µ–¥–∏
            if (player.moveQueue && player.moveProgress < 1) {
                player.moveProgress += CONFIG.PLAYER_SPEED * deltaTime / 16;
                
                if (player.moveProgress >= 1) {
                    player.moveProgress = 1;
                    player.x = player.moveQueue.toX;
                    player.y = player.moveQueue.toY;
                    player.gridX = Math.round(player.x);
                    player.gridY = Math.round(player.y);
                    player.moveQueue = null;
                    player.isMoving = false;
                } else {
                    player.x = player.moveQueue.fromX + (player.moveQueue.toX - player.moveQueue.fromX) * player.moveProgress;
                    player.y = player.moveQueue.fromY + (player.moveQueue.toY - player.moveQueue.fromY) * player.moveProgress;
                }
                return;
            }
            
            // –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤–≤–æ–¥–∞ —Å –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã
            let targetX = player.gridX;
            let targetY = player.gridY;
            let moved = false;
            
            if (keysPressed['ArrowUp'] || keysPressed['w'] || keysPressed['W']) {
                targetY--;
                moved = true;
            } else if (keysPressed['ArrowDown'] || keysPressed['s'] || keysPressed['S']) {
                targetY++;
                moved = true;
            } else if (keysPressed['ArrowLeft'] || keysPressed['a'] || keysPressed['A']) {
                targetX--;
                moved = true;
            } else if (keysPressed['ArrowRight'] || keysPressed['d'] || keysPressed['D']) {
                targetX++;
                moved = true;
            }
            
            // –ï—Å–ª–∏ –Ω—É–∂–Ω–æ –¥–≤–∏–≥–∞—Ç—å—Å—è –∏ –º–æ–∂–µ–º –¥–≤–∏–≥–∞—Ç—å—Å—è –≤ —ç—Ç—É –∫–ª–µ—Ç–∫—É
            if (moved && canMoveTo(targetX, targetY) && !player.isMoving) {
                player.moveQueue = {
                    fromX: player.x,
                    fromY: player.y,
                    toX: targetX,
                    toY: targetY
                };
                player.moveProgress = 0;
                player.isMoving = true;
                player.gridX = targetX;
                player.gridY = targetY;
            }
        }

        function updateSpirits(deltaTime) {
            spirits.forEach(spirit => {
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ñ–∞–∑—ã –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏
                spirit.phase += 0.02 * deltaTime / 16;
                
                // –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏ –≤—ã–±–∏—Ä–∞–µ–º –Ω–æ–≤—É—é —Ü–µ–ª—å
                if (spirit.moveCooldown <= 0) {
                    const directions = [
                        {dx: 0, dy: -1},
                        {dx: 1, dy: 0},
                        {dx: 0, dy: 1},
                        {dx: -1, dy: 0}
                    ];
                    
                    const validDirections = directions.filter(dir => 
                        canMoveTo(spirit.gridX + dir.dx, spirit.gridY + dir.dy)
                    );
                    
                    if (validDirections.length > 0) {
                        const dir = validDirections[Math.floor(Math.random() * validDirections.length)];
                        spirit.targetX = spirit.gridX + dir.dx;
                        spirit.targetY = spirit.gridY + dir.dy;
                    }
                    
                    spirit.moveCooldown = 60 + Math.random() * 120; // 1-3 —Å–µ–∫—É–Ω–¥—ã
                } else {
                    spirit.moveCooldown -= deltaTime / 16;
                }
                
                // –ü–ª–∞–≤–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ –∫ —Ü–µ–ª–∏
                const dx = spirit.targetX - spirit.x;
                const dy = spirit.targetY - spirit.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 0.1) {
                    spirit.x += (dx / distance) * spirit.speed * deltaTime / 16;
                    spirit.y += (dy / distance) * spirit.speed * deltaTime / 16;
                } else {
                    spirit.x = spirit.targetX;
                    spirit.y = spirit.targetY;
                    spirit.gridX = Math.round(spirit.x);
                    spirit.gridY = Math.round(spirit.y);
                }
            });
        }

        function checkCollisions() {
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫—Ä–∏—Å—Ç–∞–ª–ª–æ–≤
            crystals.forEach(crystal => {
                if (!crystal.collected && 
                    Math.abs(player.x - crystal.x) < 0.5 && 
                    Math.abs(player.y - crystal.y) < 0.5) {
                    crystal.collected = true;
                    crystalsCollected++;
                    updateUI();
                    console.log(`–°–æ–±—Ä–∞–Ω –∫—Ä–∏—Å—Ç–∞–ª–ª! –í—Å–µ–≥–æ: ${crystalsCollected}/${totalCrystals}`);
                }
            });
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–ª—é—á–∞
            if (!key.collected && 
                Math.abs(player.x - key.x) < 0.5 && 
                Math.abs(player.y - key.y) < 0.5) {
                key.collected = true;
                hasKey = true;
                updateUI();
                console.log('–ö–ª—é—á –Ω–∞–π–¥–µ–Ω!');
            }
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–≤–µ—Ä–∏
            if (Math.abs(player.x - door.x) < 0.7 && 
                Math.abs(player.y - door.y) < 0.7) {
                if (crystalsCollected === totalCrystals && hasKey) {
                    door.open = true;
                    completeLevel();
                }
            }
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥—É—Ö–æ–≤
            spirits.forEach(spirit => {
                const dist = Math.sqrt(
                    Math.pow(player.x - spirit.x, 2) + 
                    Math.pow(player.y - spirit.y, 2)
                );
                
                if (dist < 0.7) {
                    playerLives--;
                    updateUI();
                    
                    // –°–±—Ä–æ—Å –ø–æ–∑–∏—Ü–∏–∏ –∏–≥—Ä–æ–∫–∞
                    player.x = 1;
                    player.y = 1;
                    player.gridX = 1;
                    player.gridY = 1;
                    player.isMoving = false;
                    player.moveQueue = null;
                    
                    console.log(`–ü–æ—Ç–µ—Ä—è–Ω–∞ –∂–∏–∑–Ω—å! –û—Å—Ç–∞–ª–æ—Å—å: ${playerLives}`);
                    
                    if (playerLives <= 0) {
                        gameOver();
                    }
                }
            });
        }

        function updateDebugInfo() {
            document.getElementById('debug-pos').textContent = 
                `${player.x.toFixed(2)}, ${player.y.toFixed(2)}`;
            document.getElementById('debug-target').textContent = 
                `${player.gridX}, ${player.gridY}`;
            document.getElementById('debug-moving').textContent = 
                player.isMoving ? '–¥–∞' : '–Ω–µ—Ç';
            document.getElementById('debug-cell').textContent = 
                `${Math.floor(player.x)}, ${Math.floor(player.y)}`;
        }

        // ================= –û–¢–†–ò–°–û–í–ö–ê =================
        function draw() {
            // –û—á–∏—Å—Ç–∫–∞ canvas
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // –†–∞—Å—á–µ—Ç —Å–º–µ—â–µ–Ω–∏—è –¥–ª—è —Ü–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∏—è –∫–∞–º–µ—Ä—ã
            const offsetX = canvas.width / 2 - player.x * CONFIG.CELL_SIZE;
            const offsetY = canvas.height / 2 - player.y * CONFIG.CELL_SIZE;
            
            // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –ª–∞–±–∏—Ä–∏–Ω—Ç–∞
            drawMaze(offsetX, offsetY);
            
            // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –∫—Ä–∏—Å—Ç–∞–ª–ª–æ–≤
            drawCrystals(offsetX, offsetY);
            
            // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –∫–ª—é—á–∞
            drawKey(offsetX, offsetY);
            
            // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –¥–≤–µ—Ä–∏
            drawDoor(offsetX, offsetY);
            
            // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –¥—É—Ö–æ–≤
            drawSpirits(offsetX, offsetY);
            
            // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –∏–≥—Ä–æ–∫–∞
            drawPlayer(offsetX, offsetY);
            
            // –≠—Ñ—Ñ–µ–∫—Ç —Ç—É–º–∞–Ω–∞ –≤–æ–π–Ω—ã
            drawFogOfWar();
        }

        function drawMaze(offsetX, offsetY) {
            const cellSize = CONFIG.CELL_SIZE;
            
            for (let y = 0; y < maze.length; y++) {
                for (let x = 0; x < maze[y].length; x++) {
                    if (maze[y][x] === 1) {
                        // –°—Ç–µ–Ω–∞
                        ctx.fillStyle = '#111';
                        ctx.fillRect(
                            x * cellSize + offsetX,
                            y * cellSize + offsetY,
                            cellSize,
                            cellSize
                        );
                        
                        // –¢–µ–∫—Å—Ç—É—Ä–∞ —Å—Ç–µ–Ω—ã
                        ctx.fillStyle = '#222';
                        for (let i = 0; i < 2; i++) {
                            const rx = Math.random() * cellSize;
                            const ry = Math.random() * cellSize;
                            const rw = Math.random() * 2 + 1;
                            const rh = Math.random() * 2 + 1;
                            ctx.fillRect(
                                x * cellSize + offsetX + rx,
                                y * cellSize + offsetY + ry,
                                rw,
                                rh
                            );
                        }
                    } else {
                        // –ü–æ–ª (–ø—Ä–æ—Ö–æ–¥) - –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –ª–µ–≥–∫—É—é —Ç–µ–∫—Å—Ç—É—Ä—É
                        if ((x + y) % 2 === 0) {
                            ctx.fillStyle = '#050505';
                            ctx.fillRect(
                                x * cellSize + offsetX,
                                y * cellSize + offsetY,
                                cellSize,
                                cellSize
                            );
                        }
                    }
                }
            }
        }

        function drawCrystals(offsetX, offsetY) {
            const cellSize = CONFIG.CELL_SIZE;
            
            crystals.forEach(crystal => {
                if (!crystal.collected) {
                    crystal.pulse += 0.05;
                    const size = 8 + Math.sin(crystal.pulse) * 2;
                    
                    // –°–≤–µ—á–µ–Ω–∏–µ
                    ctx.shadowColor = '#00ffff';
                    ctx.shadowBlur = 15;
                    ctx.fillStyle = '#00ffff';
                    ctx.beginPath();
                    ctx.arc(
                        crystal.x * cellSize + cellSize/2 + offsetX,
                        crystal.y * cellSize + cellSize/2 + offsetY,
                        size,
                        0,
                        Math.PI * 2
                    );
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            });
        }

        function drawKey(offsetX, offsetY) {
            const cellSize = CONFIG.CELL_SIZE;
            
            if (!key.collected) {
                // –°–≤–µ—á–µ–Ω–∏–µ –∫–ª—é—á–∞
                ctx.shadowColor = '#ffaa00';
                ctx.shadowBlur = 10;
                ctx.fillStyle = '#ffaa00';
                ctx.fillRect(
                    key.x * cellSize + cellSize/4 + offsetX,
                    key.y * cellSize + cellSize/3 + offsetY,
                    cellSize/2,
                    cellSize/3
                );
                ctx.shadowBlur = 0;
                
                // –î–µ—Ç–∞–ª–∏ –∫–ª—é—á–∞
                ctx.fillStyle = '#ff8800';
                ctx.beginPath();
                ctx.arc(
                    key.x * cellSize + cellSize/2 + offsetX,
                    key.y * cellSize + cellSize/2 - 5 + offsetY,
                    6,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
            }
        }

        function drawDoor(offsetX, offsetY) {
            const cellSize = CONFIG.CELL_SIZE;
            
            ctx.fillStyle = door.open ? '#006600' : '#660000';
            ctx.fillRect(
                door.x * cellSize + offsetX,
                door.y * cellSize + offsetY,
                cellSize,
                cellSize
            );
            
            // –°–∏–º–≤–æ–ª –¥–≤–µ—Ä–∏
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(
                door.open ? '‚úì' : '‚úó',
                door.x * cellSize + cellSize/2 + offsetX,
                door.y * cellSize + cellSize/2 + offsetY
            );
        }

        function drawSpirits(offsetX, offsetY) {
            const cellSize = CONFIG.CELL_SIZE;
            
            spirits.forEach(spirit => {
                // –ü–ª–∞–≤–∞—é—â–∞—è –∞–Ω–∏–º–∞—Ü–∏—è
                const floatY = Math.sin(spirit.phase) * 3;
                
                // –¢–µ–ª–æ –¥—É—Ö–∞
                ctx.shadowColor = '#ff0000';
                ctx.shadowBlur = 20;
                ctx.fillStyle = 'rgba(255, 50, 50, 0.8)';
                ctx.beginPath();
                ctx.arc(
                    spirit.x * cellSize + cellSize/2 + offsetX,
                    spirit.y * cellSize + cellSize/2 + offsetY + floatY,
                    10,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
                ctx.shadowBlur = 0;
                
                // –ì–ª–∞–∑–∞
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(
                    spirit.x * cellSize + cellSize/2 - 3 + offsetX,
                    spirit.y * cellSize + cellSize/2 - 3 + offsetY + floatY,
                    2,
                    0,
                    Math.PI * 2
                );
                ctx.arc(
                    spirit.x * cellSize + cellSize/2 + 3 + offsetX,
                    spirit.y * cellSize + cellSize/2 - 3 + offsetY + floatY,
                    2,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
            });
        }

        function drawPlayer(offsetX, offsetY) {
            const cellSize = CONFIG.CELL_SIZE;
            
            // –°–≤–µ—á–µ–Ω–∏–µ –∏–≥—Ä–æ–∫–∞
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 25;
            ctx.fillStyle = '#00ffff';
            ctx.beginPath();
            ctx.arc(
                player.x * cellSize + cellSize/2 + offsetX,
                player.y * cellSize + cellSize/2 + offsetY,
                12,
                0,
                Math.PI * 2
            );
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // –¢–µ–ª–æ –∏–≥—Ä–æ–∫–∞
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(
                player.x * cellSize + cellSize/2 + offsetX,
                player.y * cellSize + cellSize/2 + offsetY,
                8,
                0,
                Math.PI * 2
            );
            ctx.fill();
        }

        function drawFogOfWar() {
            const radius = 200;
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –≥—Ä–∞–¥–∏–µ–Ω—Ç–∞ –¥–ª—è —Ç—É–º–∞–Ω–∞
            const gradient = ctx.createRadialGradient(
                centerX, centerY, radius * 0.3,
                centerX, centerY, radius
            );
            gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0.9)');
            
            // –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —Ç—É–º–∞–Ω–∞
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        // ================= –£–ü–†–ê–í–õ–ï–ù–ò–ï =================
        document.addEventListener('keydown', (e) => {
            keysPressed[e.key] = true;
            
            // –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ–º –ø—Ä–æ–∫—Ä—É—Ç–∫—É —Å—Ç—Ä–∞–Ω–∏—Ü—ã
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' ', 'w', 'a', 's', 'd'].includes(e.key)) {
                e.preventDefault();
            }
        });

        document.addEventListener('keyup', (e) => {
            keysPressed[e.key] = false;
        });

        // –ú–æ–±–∏–ª—å–Ω–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
        let touchStart = { x: 0, y: 0 };
        
        canvas.addEventListener('touchstart', (e) => {
            touchStart.x = e.touches[0].clientX;
            touchStart.y = e.touches[0].clientY;
            e.preventDefault();
        }, { passive: false });
        
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault(); // –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ–º –ø—Ä–æ–∫—Ä—É—Ç–∫—É
        }, { passive: false });
        
        canvas.addEventListener('touchend', (e) => {
            if (gameState !== 'playing' || player.isMoving) return;
            
            const touchEnd = {
                x: e.changedTouches[0].clientX,
                y: e.changedTouches[0].clientY
            };
            
            const dx = touchEnd.x - touchStart.x;
            const dy = touchEnd.y - touchStart.y;
            
            let targetX = player.gridX;
            let targetY = player.gridY;
            
            // –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Å–≤–∞–π–ø–∞
            if (Math.abs(dx) > Math.abs(dy)) {
                if (dx > 30) targetX++; // –í–ø—Ä–∞–≤–æ
                else if (dx < -30) targetX--; // –í–ª–µ–≤–æ
            } else {
                if (dy > 30) targetY++; // –í–Ω–∏–∑
                else if (dy < -30) targetY--; // –í–≤–µ—Ä—Ö
            }
            
            // –î–≤–∏–∂–µ–Ω–∏–µ –µ—Å–ª–∏ –≤–æ–∑–º–æ–∂–Ω–æ
            if (canMoveTo(targetX, targetY) && !player.isMoving) {
                player.moveQueue = {
                    fromX: player.x,
                    fromY: player.y,
                    toX: targetX,
                    toY: targetY
                };
                player.moveProgress = 0;
                player.isMoving = true;
                player.gridX = targetX;
                player.gridY = targetY;
            }
            
            e.preventDefault();
        }, { passive: false });

        // ================= –ò–ì–†–û–í–û–ô –¶–ò–ö–õ =================
        function gameLoop(timestamp) {
            if (!lastTime) lastTime = timestamp;
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;
            
            if (gameState === 'playing') {
                update(deltaTime);
                draw();
            }
            
            requestAnimationFrame(gameLoop);
        }

        // ================= –ò–ù–¢–ï–†–§–ï–ô–° =================
        function updateUI() {
            document.getElementById('current-level').textContent = currentLevel;
            document.getElementById('crystals').textContent = crystalsCollected;
            document.getElementById('total-crystals').textContent = totalCrystals;
            document.getElementById('key-status').textContent = hasKey ? '–î–ê' : '–ù–ï–¢';
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∂–∏–∑–Ω–µ–π
            let hearts = '';
            for (let i = 0; i < 3; i++) {
                hearts += i < playerLives ? '‚ù§Ô∏è' : 'üñ§';
            }
            document.getElementById('hearts').innerHTML = hearts;
        }

        // ================= –ò–ì–†–û–í–´–ï –°–û–ë–´–¢–ò–Ø =================
        function startGame() {
            gameState = 'playing';
            currentLevel = 1;
            playerLives = 3;
            keysPressed = {};
            lastTime = 0;
            
            document.getElementById('menu-screen').style.display = 'none';
            document.getElementById('game-screen').style.display = 'block';
            
            generateLevel(currentLevel);
            updateUI();
            
            // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –∏–≥—Ä–æ–≤–æ–π —Ü–∏–∫–ª
            requestAnimationFrame(gameLoop);
            
            console.log('–ò–≥—Ä–∞ –Ω–∞—á–∞—Ç–∞! –£—Ä–æ–≤–µ–Ω—å 1');
        }

        function completeLevel() {
            gameState = 'levelComplete';
            document.getElementById('level-complete').style.display = 'block';
            console.log(`–£—Ä–æ–≤–µ–Ω—å ${currentLevel} –ø—Ä–æ–π–¥–µ–Ω!`);
        }

        function nextLevel() {
            if (currentLevel < 5) {
                currentLevel++;
                document.getElementById('level-complete').style.display = 'none';
                generateLevel(currentLevel);
                updateUI();
                gameState = 'playing';
                console.log(`–ù–∞—á–∏–Ω–∞–µ—Ç—Å—è —É—Ä–æ–≤–µ–Ω—å ${currentLevel}`);
            } else {
                alert('üéâ –ü–û–ó–î–†–ê–í–õ–Ø–ï–ú! –í—ã –ø—Ä–æ—à–ª–∏ –≤—Å–µ —É—Ä–æ–≤–Ω–∏ –õ–∞–±–∏—Ä–∏–Ω—Ç–∞ –¢—å–º—ã!');
                returnToMenu();
            }
        }

        function gameOver() {
            alert('‚ò†Ô∏è –í–∞—Å –ø–æ–≥–ª–æ—Ç–∏–ª–∞ —Ç—å–º–∞... –ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞');
            returnToMenu();
        }

        function returnToMenu() {
            gameState = 'menu';
            document.getElementById('menu-screen').style.display = 'flex';
            document.getElementById('game-screen').style.display = 'none';
            document.getElementById('level-complete').style.display = 'none';
            document.getElementById('debug-info').style.display = 'none';
        }

        function toggleDebug() {
            CONFIG.DEBUG_MODE = !CONFIG.DEBUG_MODE;
            document.getElementById('debug-info').style.display = 
                CONFIG.DEBUG_MODE ? 'block' : 'none';
        }

        // ================= –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø =================
        window.onload = function() {
            updateUI();
            console.log('–ò–≥—Ä–∞ "–õ–∞–±–∏—Ä–∏–Ω—Ç –¢—å–º—ã" –∑–∞–≥—Ä—É–∂–µ–Ω–∞!');
            
            // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ä–∞–∑–º–µ—Ä–∞ –æ–∫–Ω–∞
            window.addEventListener('resize', () => {
                if (gameState === 'playing') {
                    draw();
                }
            });
            
            // –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ–µ –º–µ–Ω—é –Ω–∞ canvas
            canvas.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });
        };
    </script>
</body>
</html>
