<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–õ–∞–±–∏—Ä–∏–Ω—Ç –¢—å–º—ã - –ê–ª–≥–æ—Ä–∏—Ç–º –ü—Ä–∏–º–∞</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }
        
        body {
            background: #000;
            color: #e0e0e0;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
        }
        
        #game-canvas {
            display: block;
            background: #000;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.85);
            border-radius: 8px;
            border: 1px solid #333;
            backdrop-filter: blur(5px);
            min-width: 200px;
        }
        
        .ui-element {
            margin: 12px 0;
            display: flex;
            align-items: center;
            font-size: 14px;
        }
        
        .crystal-icon {
            width: 16px;
            height: 16px;
            background: linear-gradient(45deg, #00ffff, #0088ff);
            border-radius: 50%;
            margin-right: 8px;
            box-shadow: 0 0 8px #00ffff;
            animation: pulse 2s infinite;
        }
        
        .key-icon {
            width: 20px;
            height: 12px;
            background: linear-gradient(to right, #ffaa00, #ff8800);
            margin-right: 8px;
            border-radius: 3px;
            box-shadow: 0 0 6px #ffaa00;
        }
        
        .heart-icon {
            color: #ff5555;
            margin: 0 3px;
            font-size: 16px;
            text-shadow: 0 0 5px #ff0000;
        }
        
        #menu-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, #1a1a2e 0%, #0a0a0a 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            padding: 20px;
        }
        
        .title {
            font-size: 3.5rem;
            color: #00ffff;
            text-shadow: 0 0 15px #00ffff, 0 0 30px #0088ff;
            margin-bottom: 30px;
            letter-spacing: 4px;
            text-align: center;
            animation: titleGlow 3s infinite alternate;
        }
        
        .subtitle {
            font-size: 1.2rem;
            color: #888;
            margin-bottom: 40px;
            text-align: center;
            max-width: 600px;
            line-height: 1.5;
        }
        
        .menu-button {
            background: rgba(34, 34, 34, 0.8);
            color: #00ffff;
            border: 2px solid #00ffff;
            padding: 12px 30px;
            margin: 10px;
            font-size: 1.1rem;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.3s;
            min-width: 180px;
            text-align: center;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
            backdrop-filter: blur(5px);
        }
        
        .menu-button:hover {
            background: rgba(0, 255, 255, 0.2);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.7);
            transform: translateY(-2px);
        }
        
        .developer {
            position: absolute;
            bottom: 20px;
            color: #666;
            font-size: 0.8rem;
        }
        
        #game-screen {
            display: none;
            width: 100%;
            height: 100%;
        }
        
        #level-complete {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 30px;
            border-radius: 10px;
            border: 2px solid #00ff00;
            text-align: center;
            display: none;
            z-index: 50;
            backdrop-filter: blur(10px);
            min-width: 300px;
        }
        
        .glowing-text {
            color: #00ff00;
            text-shadow: 0 0 10px #00ff00;
            margin-bottom: 15px;
            font-size: 1.5rem;
        }
        
        .difficulty-selector {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 20px;
        }
        
        .difficulty-btn {
            padding: 10px 20px;
            background: rgba(34, 34, 34, 0.8);
            border: 1px solid #444;
            color: #ccc;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.3s;
        }
        
        .difficulty-btn:hover {
            border-color: #00ffff;
            color: #00ffff;
        }
        
        .difficulty-btn.active {
            border-color: #00ffff;
            color: #00ffff;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            background: rgba(0, 255, 255, 0.1);
        }
        
        .instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 30px;
            border-radius: 10px;
            border: 1px solid #444;
            max-width: 500px;
            display: none;
            z-index: 50;
            backdrop-filter: blur(10px);
        }
        
        .close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #ccc;
            cursor: pointer;
            font-size: 20px;
        }
        
        @keyframes pulse {
            0% { opacity: 0.7; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.1); }
            100% { opacity: 0.7; transform: scale(1); }
        }
        
        @keyframes titleGlow {
            0% { text-shadow: 0 0 15px #00ffff, 0 0 30px #0088ff; }
            100% { text-shadow: 0 0 20px #00ffff, 0 0 40px #0088ff, 0 0 60px #0088ff; }
        }
        
        @keyframes spiritFloat {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }
        
        @media (max-width: 768px) {
            .title { font-size: 2.5rem; }
            #ui { 
                top: 10px; 
                left: 10px; 
                padding: 10px;
                font-size: 12px;
            }
            .menu-button { 
                padding: 10px 20px; 
                min-width: 150px; 
                font-size: 1rem;
            }
        }
        
        #controls-info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            color: #888;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="menu-screen">
            <h1 class="title">–õ–ê–ë–ò–†–ò–ù–¢ –¢–¨–ú–´</h1>
            <p class="subtitle">–ù–∞–π–¥–∏ –≤—Å–µ –∫—Ä–∏—Å—Ç–∞–ª–ª—ã, –ø–æ–ª—É—á–∏ –∫–ª—é—á –∏ –±–µ–≥–∏ –æ—Ç –¥—É—Ö–æ–≤ –ª–∞–±–∏—Ä–∏–Ω—Ç–∞</p>
            <div id="menu-buttons">
                <div class="menu-button" onclick="startGame()">–ù–ê–ß–ê–¢–¨ –ò–ì–†–£</div>
                <div class="menu-button" onclick="showDifficultyMenu()">–£–†–û–í–ï–ù–¨ –°–õ–û–ñ–ù–û–°–¢–ò</div>
                <div class="menu-button" onclick="showInstructions()">–ò–ù–°–¢–†–£–ö–¶–ò–Ø</div>
            </div>
            <div class="developer">–†–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫: –ü—Ä–æ—Å–≤–µ—Ç–æ–≤ –°–µ—Ä–≥–µ–π –ù–∏–∫–æ–ª–∞–µ–≤–∏—á</div>
        </div>
        
        <div id="game-screen">
            <canvas id="game-canvas"></canvas>
            <div id="ui">
                <div class="ui-element">
                    <div>–£—Ä–æ–≤–µ–Ω—å: <span id="current-level">1</span>/5</div>
                </div>
                <div class="ui-element">
                    <div class="crystal-icon"></div>
                    <div>–ö—Ä–∏—Å—Ç–∞–ª–ª—ã: <span id="crystals">0</span>/<span id="total-crystals">3</span></div>
                </div>
                <div class="ui-element">
                    <div class="key-icon"></div>
                    <div>–ö–ª—é—á: <span id="key-status">–ù–ï–¢</span></div>
                </div>
                <div class="ui-element">
                    <div>–ñ–∏–∑–Ω–∏: <span id="hearts">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</span></div>
                </div>
                <div class="ui-element">
                    <div>–°–ª–æ–∂–Ω–æ—Å—Ç—å: <span id="difficulty">–ü–æ–∫–æ–π</span></div>
                </div>
                <div class="ui-element">
                    <div>–í—Ä–µ–º—è: <span id="timer">00:00</span></div>
                </div>
                <div class="menu-button" onclick="returnToMenu()" style="margin: 10px 0 0 0; padding: 8px; font-size: 0.9rem;">
                    –í –ú–ï–ù–Æ
                </div>
            </div>
            
            <div id="controls-info">
                –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: WASD –∏–ª–∏ —Å—Ç—Ä–µ–ª–∫–∏<br>
                –¶–µ–ª—å: –°–æ–±—Ä–∞—Ç—å –≤—Å–µ –∫—Ä–∏—Å—Ç–∞–ª–ª—ã<br>
                –ù–∞–π—Ç–∏ –∫–ª—é—á ‚Üí –í—ã–π—Ç–∏ —á–µ—Ä–µ–∑ –¥–≤–µ—Ä—å
            </div>
        </div>
        
        <div id="level-complete">
            <h2 class="glowing-text">–£–†–û–í–ï–ù–¨ –ü–†–û–ô–î–ï–ù!</h2>
            <p>–í—Å–µ –∫—Ä–∏—Å—Ç–∞–ª–ª—ã —Å–æ–±—Ä–∞–Ω—ã</p>
            <p>–î–≤–µ—Ä—å –æ—Ç–∫—Ä—ã—Ç–∞</p>
            <div class="menu-button" onclick="nextLevel()">–°–õ–ï–î–£–Æ–©–ò–ô –£–†–û–í–ï–ù–¨</div>
        </div>
        
        <div id="difficulty-menu" class="instructions">
            <div class="close-btn" onclick="hideDifficultyMenu()">√ó</div>
            <h2>–í–´–ë–ï–†–ò–¢–ï –°–õ–û–ñ–ù–û–°–¢–¨</h2>
            <div class="difficulty-selector">
                <div class="difficulty-btn" onclick="setDifficulty('–ü–æ–∫–æ–π')">–ü–û–ö–û–ô (–ª–µ–≥–∫–æ)</div>
                <div class="difficulty-btn" onclick="setDifficulty('–¢—Ä–µ–≤–æ–≥–∞')">–¢–†–ï–í–û–ì–ê (–Ω–æ—Ä–º–∞–ª—å–Ω–æ)</div>
                <div class="difficulty-btn" onclick="setDifficulty('–°—Ç—Ä–∞—Ö')">–°–¢–†–ê–• (—Å–ª–æ–∂–Ω–æ)</div>
                <div class="difficulty-btn" onclick="setDifficulty('–£–∂–∞—Å')">–£–ñ–ê–° (–æ—á–µ–Ω—å —Å–ª–æ–∂–Ω–æ)</div>
                <div class="difficulty-btn" onclick="setDifficulty('–ü–∞–Ω–∏–∫–∞')">–ü–ê–ù–ò–ö–ê (—ç–∫—Å–ø–µ—Ä—Ç)</div>
                <div class="difficulty-btn" onclick="setDifficulty('–ö–æ—à–º–∞—Ä')">–ö–û–®–ú–ê–† (–Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ)</div>
            </div>
        </div>
        
        <div id="instructions-screen" class="instructions">
            <div class="close-btn" onclick="hideInstructions()">√ó</div>
            <h2>–ò–ù–°–¢–†–£–ö–¶–ò–Ø</h2>
            <p><strong>–¶–µ–ª—å –∏–≥—Ä—ã:</strong></p>
            <p>1. –°–æ–±—Ä–∞—Ç—å –≤—Å–µ –∫—Ä–∏—Å—Ç–∞–ª–ª—ã –Ω–∞ —É—Ä–æ–≤–Ω–µ</p>
            <p>2. –ù–∞–π—Ç–∏ –∫–ª—é—á –æ—Ç –¥–≤–µ—Ä–∏</p>
            <p>3. –î–æ–±—Ä–∞—Ç—å—Å—è –¥–æ –≤—ã—Ö–æ–¥–∞</p>
            <p><strong>–û—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏:</strong></p>
            <p>‚Ä¢ –ò–∑–±–µ–≥–∞–π—Ç–µ –¥—É—Ö–æ–≤ –ª–∞–±–∏—Ä–∏–Ω—Ç–∞</p>
            <p>‚Ä¢ –£ –≤–∞—Å –µ—Å—Ç—å 3 –∂–∏–∑–Ω–∏</p>
            <p>‚Ä¢ –õ–∞–±–∏—Ä–∏–Ω—Ç –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç—Å—è —Å–ª—É—á–∞–π–Ω–æ</p>
            <p>‚Ä¢ –ö–∞–∂–¥—ã–π —É—Ä–æ–≤–µ–Ω—å —Å–ª–æ–∂–Ω–µ–µ –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ</p>
            <p><strong>–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ:</strong></p>
            <p>‚Ä¢ WASD –∏–ª–∏ —Å—Ç—Ä–µ–ª–∫–∏ - –¥–≤–∏–∂–µ–Ω–∏–µ</p>
            <p>‚Ä¢ –ù–∞ –º–æ–±–∏–ª—å–Ω—ã—Ö: —Ç–∞–ø –ø–æ –∫—Ä–∞—è–º —ç–∫—Ä–∞–Ω–∞</p>
        </div>
    </div>

    <script>
        // ================= –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø =================
        const CONFIG = {
            CELL_SIZE: 40,
            MAZE_WIDTH: 21,  // –ù–µ—á–µ—Ç–Ω–æ–µ —á–∏—Å–ª–æ –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–π —Ä–∞–±–æ—Ç—ã –∞–ª–≥–æ—Ä–∏—Ç–º–∞
            MAZE_HEIGHT: 21, // –ù–µ—á–µ—Ç–Ω–æ–µ —á–∏—Å–ª–æ
            PLAYER_SPEED: 0.15,
            FOV_RADIUS: {
                '–ü–æ–∫–æ–π': 250,
                '–¢—Ä–µ–≤–æ–≥–∞': 220,
                '–°—Ç—Ä–∞—Ö': 180,
                '–£–∂–∞—Å': 140,
                '–ü–∞–Ω–∏–∫–∞': 100,
                '–ö–æ—à–º–∞—Ä': 80
            },
            SPIRIT_SPEED: {
                '–ü–æ–∫–æ–π': 0.03,
                '–¢—Ä–µ–≤–æ–≥–∞': 0.05,
                '–°—Ç—Ä–∞—Ö': 0.07,
                '–£–∂–∞—Å': 0.09,
                '–ü–∞–Ω–∏–∫–∞': 0.11,
                '–ö–æ—à–º–∞—Ä': 0.13
            },
            SPIRIT_COUNT: {
                1: 2,
                2: 3,
                3: 4,
                4: 5,
                5: 6
            },
            CRYSTAL_COUNT: {
                1: 3,
                2: 4,
                3: 4,
                4: 5,
                5: 5
            }
        };

        // ================= –ü–ï–†–ï–ú–ï–ù–ù–´–ï –ò–ì–†–´ =================
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        
        let gameState = 'menu';
        let currentLevel = 1;
        let crystalsCollected = 0;
        let totalCrystals = 3;
        let hasKey = false;
        let playerLives = 3;
        let difficulty = '–ü–æ–∫–æ–π';
        let maze = [];
        let player = { x: 1, y: 1, targetX: 1, targetY: 1, moving: false };
        let crystals = [];
        let key = { x: 0, y: 0, collected: false };
        let door = { x: 0, y: 0, open: false };
        let spirits = [];
        let startTime = 0;
        let gameTime = 0;
        let gameTimer;

        // ================= –ê–õ–ì–û–†–ò–¢–ú –ü–†–ò–ú–ê =================
        function generateMazePrim(width, height) {
            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ª–∞–±–∏—Ä–∏–Ω—Ç–∞ (1 - —Å—Ç–µ–Ω–∞, 0 - –ø—Ä–æ—Ö–æ–¥)
            const maze = Array(height).fill().map(() => Array(width).fill(1));
            
            // –ù–∞—á–∞–ª—å–Ω–∞—è –∫–ª–µ—Ç–∫–∞ (–≤—Å–µ–≥–¥–∞ –Ω–µ—á–µ—Ç–Ω—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã)
            const startX = 1;
            const startY = 1;
            maze[startY][startX] = 0;
            
            // –°–ø–∏—Å–æ–∫ –≥—Ä–∞–Ω–∏—á–Ω—ã—Ö —Å—Ç–µ–Ω
            let walls = [];
            
            // –î–æ–±–∞–≤–ª—è–µ–º —Å—Ç–µ–Ω—ã –≤–æ–∫—Ä—É–≥ –Ω–∞—á–∞–ª—å–Ω–æ–π –∫–ª–µ—Ç–∫–∏
            addWalls(startX, startY, walls, maze);
            
            while (walls.length > 0) {
                // –°–ª—É—á–∞–π–Ω—ã–π –≤—ã–±–æ—Ä —Å—Ç–µ–Ω—ã
                const randomIndex = Math.floor(Math.random() * walls.length);
                const wall = walls[randomIndex];
                walls.splice(randomIndex, 1);
                
                const { x, y, fromX, fromY } = wall;
                
                // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∫–ª–µ—Ç–∫—É –∑–∞ —Å—Ç–µ–Ω–æ–π
                const toX = x + (x - fromX);
                const toY = y + (y - fromY);
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∫–ª–µ—Ç–∫–∞ –∑–∞ —Å—Ç–µ–Ω–æ–π –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö –ª–∞–±–∏—Ä–∏–Ω—Ç–∞
                if (toX > 0 && toX < width - 1 && toY > 0 && toY < height - 1) {
                    // –ï—Å–ª–∏ –∫–ª–µ—Ç–∫–∞ –∑–∞ —Å—Ç–µ–Ω–æ–π –µ—â–µ —Å—Ç–µ–Ω–∞
                    if (maze[toY][toX] === 1) {
                        // –î–µ–ª–∞–µ–º –ø—Ä–æ—Ö–æ–¥ –≤ —Å—Ç–µ–Ω–µ –∏ –≤ –∫–ª–µ—Ç–∫–µ –∑–∞ –Ω–µ–π
                        maze[y][x] = 0;
                        maze[toY][toX] = 0;
                        
                        // –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–µ —Å—Ç–µ–Ω—ã
                        addWalls(toX, toY, walls, maze);
                    }
                }
            }
            
            return maze;
        }

        function addWalls(x, y, walls, maze) {
            const directions = [
                { dx: 0, dy: -2 }, // –≤–≤–µ—Ä—Ö
                { dx: 0, dy: 2 },  // –≤–Ω–∏–∑
                { dx: -2, dy: 0 }, // –≤–ª–µ–≤–æ
                { dx: 2, dy: 0 }   // –≤–ø—Ä–∞–≤–æ
            ];
            
            for (const dir of directions) {
                const newX = x + dir.dx;
                const newY = y + dir.dy;
                
                if (newX > 0 && newX < maze[0].length - 1 && 
                    newY > 0 && newY < maze.length - 1 && 
                    maze[newY][newX] === 1) {
                    walls.push({
                        x: x + dir.dx / 2,
                        y: y + dir.dy / 2,
                        fromX: x,
                        fromY: y
                    });
                }
            }
        }

        // ================= –ì–ï–ù–ï–†–ê–¶–ò–Ø –£–†–û–í–ù–Ø =================
        function generateLevel(level) {
            // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ª–∞–±–∏—Ä–∏–Ω—Ç–∞
            maze = generateMazePrim(CONFIG.MAZE_WIDTH, CONFIG.MAZE_HEIGHT);
            
            // –û—á–∏—Å—Ç–∫–∞ –æ–±—ä–µ–∫—Ç–æ–≤
            crystals = [];
            spirits = [];
            
            // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —É—Ä–æ–≤–Ω—è
            totalCrystals = CONFIG.CRYSTAL_COUNT[level];
            const spiritCount = CONFIG.SPIRIT_COUNT[level];
            
            // –ü–æ–∑–∏—Ü–∏—è –∏–≥—Ä–æ–∫–∞ (–≤—Å–µ–≥–¥–∞ –≤ –ª–µ–≤–æ–º –≤–µ—Ä—Ö–Ω–µ–º —É–≥–ª—É)
            player.x = 1;
            player.y = 1;
            player.targetX = 1;
            player.targetY = 1;
            player.moving = false;
            
            // –ü–æ–∏—Å–∫ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∫–ª–µ—Ç–æ–∫ –¥–ª—è —Ä–∞–∑–º–µ—â–µ–Ω–∏—è –æ–±—ä–µ–∫—Ç–æ–≤
            const availableCells = [];
            for (let y = 0; y < maze.length; y++) {
                for (let x = 0; x < maze[y].length; x++) {
                    if (maze[y][x] === 0 && 
                        !(x === player.x && y === player.y) &&
                        distance(x, y, player.x, player.y) > 5) {
                        availableCells.push({ x, y });
                    }
                }
            }
            
            // –ü–µ—Ä–µ–º–µ—à–∏–≤–∞–Ω–∏–µ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∫–ª–µ—Ç–æ–∫
            shuffleArray(availableCells);
            
            // –†–∞–∑–º–µ—â–µ–Ω–∏–µ –∫—Ä–∏—Å—Ç–∞–ª–ª–æ–≤
            for (let i = 0; i < totalCrystals && availableCells.length > 0; i++) {
                const cell = availableCells.pop();
                crystals.push({
                    x: cell.x,
                    y: cell.y,
                    collected: false,
                    pulse: Math.random() * Math.PI * 2
                });
            }
            
            // –†–∞–∑–º–µ—â–µ–Ω–∏–µ –∫–ª—é—á–∞
            if (availableCells.length > 0) {
                const keyCell = availableCells.pop();
                key = {
                    x: keyCell.x,
                    y: keyCell.y,
                    collected: false
                };
            }
            
            // –†–∞–∑–º–µ—â–µ–Ω–∏–µ –¥–≤–µ—Ä–∏ (–≤ –ø—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–Ω–æ–º —É–≥–ª—É –æ—Ç –∏–≥—Ä–æ–∫–∞)
            door = {
                x: CONFIG.MAZE_WIDTH - 2,
                y: CONFIG.MAZE_HEIGHT - 2,
                open: false
            };
            
            // –†–∞–∑–º–µ—â–µ–Ω–∏–µ –¥—É—Ö–æ–≤
            for (let i = 0; i < spiritCount && availableCells.length > 0; i++) {
                const cell = availableCells.pop();
                spirits.push({
                    x: cell.x,
                    y: cell.y,
                    targetX: cell.x,
                    targetY: cell.y,
                    speed: CONFIG.SPIRIT_SPEED[difficulty],
                    phase: Math.random() * Math.PI * 2,
                    lastDirectionChange: 0,
                    directionChangeInterval: 1000 + Math.random() * 2000,
                    path: []
                });
            }
            
            // –°–±—Ä–æ—Å —Å–æ—Å—Ç–æ—è–Ω–∏–π
            crystalsCollected = 0;
            hasKey = false;
            door.open = false;
        }

        // ================= –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò =================
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function distance(x1, y1, x2, y2) {
            return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
        }

        function findPath(startX, startY, targetX, targetY) {
            // –£–ø—Ä–æ—â–µ–Ω–Ω—ã–π –ø–æ–∏—Å–∫ –ø—É—Ç–∏ (–¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏)
            // –í —Ä–µ–∞–ª—å–Ω–æ–π –∏–≥—Ä–µ –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å A* –∞–ª–≥–æ—Ä–∏—Ç–º
            const dirs = [
                { dx: 0, dy: -1 },
                { dx: 1, dy: 0 },
                { dx: 0, dy: 1 },
                { dx: -1, dy: 0 }
            ];
            
            const visited = Array(CONFIG.MAZE_HEIGHT).fill().map(() => Array(CONFIG.MAZE_WIDTH).fill(false));
            const queue = [{ x: startX, y: startY, path: [] }];
            visited[startY][startX] = true;
            
            while (queue.length > 0) {
                const current = queue.shift();
                
                if (current.x === targetX && current.y === targetY) {
                    return current.path.length > 0 ? [current.path[0]] : [];
                }
                
                shuffleArray(dirs);
                for (const dir of dirs) {
                    const newX = current.x + dir.dx;
                    const newY = current.y + dir.dy;
                    
                    if (newX >= 0 && newX < CONFIG.MAZE_WIDTH && 
                        newY >= 0 && newY < CONFIG.MAZE_HEIGHT &&
                        maze[newY][newX] === 0 && 
                        !visited[newY][newX]) {
                        visited[newY][newX] = true;
                        queue.push({
                            x: newX,
                            y: newY,
                            path: [...current.path, { x: newX, y: newY }]
                        });
                    }
                }
            }
            
            return [];
        }

        // ================= –ò–ì–†–û–í–û–ô –¶–ò–ö–õ =================
        function gameLoop() {
            if (gameState !== 'playing') return;
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏
            gameTime = Math.floor((Date.now() - startTime) / 1000);
            updateTimer();
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏ –∏–≥—Ä–æ–∫–∞
            updatePlayer();
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥—É—Ö–æ–≤
            updateSpirits();
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π
            checkCollisions();
            
            // –û—Ç—Ä–∏—Å–æ–≤–∫–∞
            draw();
            
            requestAnimationFrame(gameLoop);
        }

        function updatePlayer() {
            if (!player.moving) return;
            
            const dx = player.targetX - player.x;
            const dy = player.targetY - player.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < 0.05) {
                player.x = player.targetX;
                player.y = player.targetY;
                player.moving = false;
            } else {
                player.x += (dx / dist) * CONFIG.PLAYER_SPEED;
                player.y += (dy / dist) * CONFIG.PLAYER_SPEED;
            }
        }

        function updateSpirits() {
            const now = Date.now();
            
            spirits.forEach(spirit => {
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ü–µ–ª–∏ –¥–ª—è –¥—É—Ö–∞
                if (now - spirit.lastDirectionChange > spirit.directionChangeInterval) {
                    spirit.lastDirectionChange = now;
                    spirit.directionChangeInterval = 500 + Math.random() * 1500;
                    
                    // –ò–Ω–æ–≥–¥–∞ –ø—Ä–µ—Å–ª–µ–¥—É–µ—Ç –∏–≥—Ä–æ–∫–∞
                    if (Math.random() < 0.3) {
                        spirit.path = findPath(
                            Math.floor(spirit.x), 
                            Math.floor(spirit.y), 
                            Math.floor(player.x), 
                            Math.floor(player.y)
                        );
                    } else {
                        // –°–ª—É—á–∞–π–Ω–æ–µ –±–ª—É–∂–¥–∞–Ω–∏–µ
                        const dirs = [
                            { dx: 0, dy: -1 },
                            { dx: 1, dy: 0 },
                            { dx: 0, dy: 1 },
                            { dx: -1, dy: 0 }
                        ].filter(dir => {
                            const newX = Math.floor(spirit.x) + dir.dx;
                            const newY = Math.floor(spirit.y) + dir.dy;
                            return maze[newY] && maze[newY][newX] === 0;
                        });
                        
                        if (dirs.length > 0) {
                            const dir = dirs[Math.floor(Math.random() * dirs.length)];
                            spirit.targetX = Math.floor(spirit.x) + dir.dx;
                            spirit.targetY = Math.floor(spirit.y) + dir.dy;
                        }
                    }
                }
                
                // –î–≤–∏–∂–µ–Ω–∏–µ –ø–æ –ø—É—Ç–∏
                if (spirit.path.length > 0) {
                    const next = spirit.path[0];
                    spirit.targetX = next.x;
                    spirit.targetY = next.y;
                    
                    const dist = distance(spirit.x, spirit.y, next.x, next.y);
                    if (dist < 0.1) {
                        spirit.path.shift();
                    }
                }
                
                // –ü–ª–∞–≤–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ –∫ —Ü–µ–ª–∏
                const dx = spirit.targetX - spirit.x;
                const dy = spirit.targetY - spirit.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > 0.05) {
                    spirit.x += (dx / dist) * spirit.speed;
                    spirit.y += (dy / dist) * spirit.speed;
                }
                
                // –ê–Ω–∏–º–∞—Ü–∏—è —Ñ–∞–∑—ã
                spirit.phase += 0.05;
            });
        }

        function checkCollisions() {
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫—Ä–∏—Å—Ç–∞–ª–ª–æ–≤
            crystals.forEach(crystal => {
                if (!crystal.collected && 
                    distance(player.x, player.y, crystal.x, crystal.y) < 0.5) {
                    crystal.collected = true;
                    crystalsCollected++;
                    updateUI();
                }
            });
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–ª—é—á–∞
            if (!key.collected && 
                distance(player.x, player.y, key.x, key.y) < 0.5) {
                key.collected = true;
                hasKey = true;
                updateUI();
            }
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–≤–µ—Ä–∏
            if (distance(player.x, player.y, door.x, door.y) < 0.7) {
                if (crystalsCollected === totalCrystals && hasKey) {
                    door.open = true;
                    completeLevel();
                }
            }
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥—É—Ö–æ–≤
            spirits.forEach(spirit => {
                if (distance(player.x, player.y, spirit.x, spirit.y) < 0.7) {
                    playerLives--;
                    updateUI();
                    
                    // –≠—Ñ—Ñ–µ–∫—Ç –ø–æ–ª—É—á–µ–Ω–∏—è —É—Ä–æ–Ω–∞
                    player.x = 1;
                    player.y = 1;
                    player.targetX = 1;
                    player.targetY = 1;
                    player.moving = false;
                    
                    if (playerLives <= 0) {
                        gameOver();
                    }
                }
            });
        }

        // ================= –û–¢–†–ò–°–û–í–ö–ê =================
        function draw() {
            // –û—á–∏—Å—Ç–∫–∞ canvas
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // –†–∞—Å—á–µ—Ç —Å–º–µ—â–µ–Ω–∏—è –¥–ª—è —Ü–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∏—è –∫–∞–º–µ—Ä—ã
            const offsetX = canvas.width / 2 - player.x * CONFIG.CELL_SIZE;
            const offsetY = canvas.height / 2 - player.y * CONFIG.CELL_SIZE;
            
            // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –ª–∞–±–∏—Ä–∏–Ω—Ç–∞
            drawMaze(offsetX, offsetY);
            
            // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –∫—Ä–∏—Å—Ç–∞–ª–ª–æ–≤
            drawCrystals(offsetX, offsetY);
            
            // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –∫–ª—é—á–∞
            drawKey(offsetX, offsetY);
            
            // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –¥–≤–µ—Ä–∏
            drawDoor(offsetX, offsetY);
            
            // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –¥—É—Ö–æ–≤
            drawSpirits(offsetX, offsetY);
            
            // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –∏–≥—Ä–æ–∫–∞
            drawPlayer(offsetX, offsetY);
            
            // –≠—Ñ—Ñ–µ–∫—Ç —Ç—É–º–∞–Ω–∞ –≤–æ–π–Ω—ã
            drawFogOfWar();
        }

        function drawMaze(offsetX, offsetY) {
            for (let y = 0; y < maze.length; y++) {
                for (let x = 0; x < maze[y].length; x++) {
                    if (maze[y][x] === 1) {
                        // –°—Ç–µ–Ω–∞
                        ctx.fillStyle = '#111';
                        ctx.fillRect(
                            x * CONFIG.CELL_SIZE + offsetX,
                            y * CONFIG.CELL_SIZE + offsetY,
                            CONFIG.CELL_SIZE,
                            CONFIG.CELL_SIZE
                        );
                        
                        // –¢–µ–∫—Å—Ç—É—Ä–∞ —Å—Ç–µ–Ω—ã
                        ctx.fillStyle = '#222';
                        for (let i = 0; i < 4; i++) {
                            const rx = Math.random() * CONFIG.CELL_SIZE;
                            const ry = Math.random() * CONFIG.CELL_SIZE;
                            const rw = Math.random() * 3 + 1;
                            const rh = Math.random() * 3 + 1;
                            ctx.fillRect(
                                x * CONFIG.CELL_SIZE + offsetX + rx,
                                y * CONFIG.CELL_SIZE + offsetY + ry,
                                rw,
                                rh
                            );
                        }
                    }
                }
            }
        }

        function drawCrystals(offsetX, offsetY) {
            crystals.forEach(crystal => {
                if (!crystal.collected) {
                    crystal.pulse += 0.1;
                    const size = 10 + Math.sin(crystal.pulse) * 3;
                    
                    // –°–≤–µ—á–µ–Ω–∏–µ
                    ctx.shadowColor = '#00ffff';
                    ctx.shadowBlur = 20;
                    ctx.fillStyle = '#00ffff';
                    ctx.beginPath();
                    ctx.arc(
                        crystal.x * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE/2 + offsetX,
                        crystal.y * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE/2 + offsetY,
                        size,
                        0,
                        Math.PI * 2
                    );
                    ctx.fill();
                    
                    // –í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è —á–∞—Å—Ç—å
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(
                        crystal.x * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE/2 + offsetX,
                        crystal.y * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE/2 + offsetY,
                        size * 0.6,
                        0,
                        Math.PI * 2
                    );
                    ctx.fill();
                }
            });
        }

        function drawKey(offsetX, offsetY) {
            if (!key.collected) {
                // –°–≤–µ—á–µ–Ω–∏–µ
                ctx.shadowColor = '#ffaa00';
                ctx.shadowBlur = 15;
                ctx.fillStyle = '#ffaa00';
                ctx.fillRect(
                    key.x * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE/4 + offsetX,
                    key.y * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE/3 + offsetY,
                    CONFIG.CELL_SIZE/2,
                    CONFIG.CELL_SIZE/3
                );
                
                // –î–µ—Ç–∞–ª–∏ –∫–ª—é—á–∞
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#ff8800';
                ctx.fillRect(
                    key.x * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE/2 - 5 + offsetX,
                    key.y * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE/2 - 10 + offsetY,
                    10,
                    20
                );
                
                ctx.beginPath();
                ctx.arc(
                    key.x * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE/2 + offsetX,
                    key.y * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE/2 - 15 + offsetY,
                    8,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
            }
        }

        function drawDoor(offsetX, offsetY) {
            ctx.fillStyle = door.open ? '#006600' : '#660000';
            ctx.fillRect(
                door.x * CONFIG.CELL_SIZE + offsetX,
                door.y * CONFIG.CELL_SIZE + offsetY,
                CONFIG.CELL_SIZE,
                CONFIG.CELL_SIZE
            );
            
            // –°–≤–µ—á–µ–Ω–∏–µ –¥–≤–µ—Ä–∏
            ctx.shadowColor = door.open ? '#00ff00' : '#ff0000';
            ctx.shadowBlur = door.open ? 20 : 10;
            ctx.fillRect(
                door.x * CONFIG.CELL_SIZE + offsetX,
                door.y * CONFIG.CELL_SIZE + offsetY,
                CONFIG.CELL_SIZE,
                CONFIG.CELL_SIZE
            );
            ctx.shadowBlur = 0;
            
            // –°–∏–º–≤–æ–ª –¥–≤–µ—Ä–∏
            ctx.fillStyle = '#ffffff';
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(
                door.open ? '‚Üì' : 'X',
                door.x * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE/2 + offsetX,
                door.y * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE/2 + offsetY
            );
        }

        function drawSpirits(offsetX, offsetY) {
            spirits.forEach(spirit => {
                // –ü–ª–∞–≤–∞—é—â–∞—è –∞–Ω–∏–º–∞—Ü–∏—è
                const floatY = Math.sin(spirit.phase) * 5;
                
                // –¢–µ–ª–æ –¥—É—Ö–∞
                ctx.shadowColor = '#ff0000';
                ctx.shadowBlur = 25;
                ctx.fillStyle = 'rgba(255, 100, 100, 0.8)';
                ctx.beginPath();
                ctx.arc(
                    spirit.x * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE/2 + offsetX,
                    spirit.y * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE/2 + offsetY + floatY,
                    12,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
                
                // –ì–ª–∞–∑–∞
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(
                    spirit.x * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE/2 - 4 + offsetX,
                    spirit.y * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE/2 - 4 + offsetY + floatY,
                    3,
                    0,
                    Math.PI * 2
                );
                ctx.arc(
                    spirit.x * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE/2 + 4 + offsetX,
                    spirit.y * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE/2 - 4 + offsetY + floatY,
                    3,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
            });
        }

        function drawPlayer(offsetX, offsetY) {
            // –°–≤–µ—á–µ–Ω–∏–µ –∏–≥—Ä–æ–∫–∞
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 30;
            ctx.fillStyle = '#00ffff';
            ctx.beginPath();
            ctx.arc(
                player.x * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE/2 + offsetX,
                player.y * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE/2 + offsetY,
                15,
                0,
                Math.PI * 2
            );
            ctx.fill();
            
            // –¢–µ–ª–æ –∏–≥—Ä–æ–∫–∞
            ctx.shadowBlur = 0;
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(
                player.x * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE/2 + offsetX,
                player.y * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE/2 + offsetY,
                10,
                0,
                Math.PI * 2
            );
            ctx.fill();
            
            // –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –≤–∑–≥–ª—è–¥–∞
            ctx.fillStyle = '#0088ff';
            ctx.beginPath();
            ctx.arc(
                player.x * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE/2 + offsetX,
                player.y * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE/2 - 5 + offsetY,
                4,
                0,
                Math.PI * 2
            );
            ctx.fill();
        }

        function drawFogOfWar() {
            const radius = CONFIG.FOV_RADIUS[difficulty];
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –≥—Ä–∞–¥–∏–µ–Ω—Ç–∞ –¥–ª—è —Ç—É–º–∞–Ω–∞
            const gradient = ctx.createRadialGradient(
                centerX, centerY, radius * 0.5,
                centerX, centerY, radius
            );
            gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0.95)');
            
            // –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —Ç—É–º–∞–Ω–∞
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        // ================= –£–ü–†–ê–í–õ–ï–ù–ò–ï =================
        document.addEventListener('keydown', (e) => {
            if (gameState !== 'playing' || player.moving) return;
            
            let newX = player.targetX;
            let newY = player.targetY;
            
            switch(e.key.toLowerCase()) {
                case 'arrowup':
                case 'w':
                    newY -= 1;
                    break;
                case 'arrowdown':
                case 's':
                    newY += 1;
                    break;
                case 'arrowleft':
                case 'a':
                    newX -= 1;
                    break;
                case 'arrowright':
                case 'd':
                    newX += 1;
                    break;
            }
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –¥–≤–∏–∂–µ–Ω–∏—è
            if (newX >= 0 && newX < CONFIG.MAZE_WIDTH && 
                newY >= 0 && newY < CONFIG.MAZE_HEIGHT &&
                maze[newY][newX] === 0) {
                player.targetX = newX;
                player.targetY = newY;
                player.moving = true;
            }
        });

        // –ú–æ–±–∏–ª—å–Ω–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
        let touchStart = { x: 0, y: 0 };
        
        canvas.addEventListener('touchstart', (e) => {
            touchStart.x = e.touches[0].clientX;
            touchStart.y = e.touches[0].clientY;
            e.preventDefault();
        });
        
        canvas.addEventListener('touchend', (e) => {
            if (gameState !== 'playing' || player.moving) return;
            
            const touchEnd = {
                x: e.changedTouches[0].clientX,
                y: e.changedTouches[0].clientY
            };
            
            const dx = touchEnd.x - touchStart.x;
            const dy = touchEnd.y - touchStart.y;
            
            let newX = player.targetX;
            let newY = player.targetY;
            
            // –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Å–≤–∞–π–ø–∞
            if (Math.abs(dx) > Math.abs(dy)) {
                if (dx > 20) newX += 1; // –í–ø—Ä–∞–≤–æ
                else if (dx < -20) newX -= 1; // –í–ª–µ–≤–æ
            } else {
                if (dy > 20) newY += 1; // –í–Ω–∏–∑
                else if (dy < -20) newY -= 1; // –í–≤–µ—Ä—Ö
            }
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –¥–≤–∏–∂–µ–Ω–∏—è
            if (newX >= 0 && newX < CONFIG.MAZE_WIDTH && 
                newY >= 0 && newY < CONFIG.MAZE_HEIGHT &&
                maze[newY][newX] === 0) {
                player.targetX = newX;
                player.targetY = newY;
                player.moving = true;
            }
            
            e.preventDefault();
        });

        // ================= –ò–ù–¢–ï–†–§–ï–ô–° =================
        function updateUI() {
            document.getElementById('current-level').textContent = currentLevel;
            document.getElementById('crystals').textContent = crystalsCollected;
            document.getElementById('total-crystals').textContent = totalCrystals;
            document.getElementById('key-status').textContent = hasKey ? '–î–ê' : '–ù–ï–¢';
            document.getElementById('difficulty').textContent = difficulty;
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∂–∏–∑–Ω–µ–π
            let hearts = '';
            for (let i = 0; i < 3; i++) {
                hearts += i < playerLives ? '‚ù§Ô∏è' : 'üñ§';
            }
            document.getElementById('hearts').innerHTML = hearts;
        }

        function updateTimer() {
            const minutes = Math.floor(gameTime / 60).toString().padStart(2, '0');
            const seconds = (gameTime % 60).toString().padStart(2, '0');
            document.getElementById('timer').textContent = `${minutes}:${seconds}`;
        }

        // ================= –ò–ì–†–û–í–´–ï –°–û–ë–´–¢–ò–Ø =================
        function startGame() {
            gameState = 'playing';
            currentLevel = 1;
            playerLives = 3;
            startTime = Date.now();
            
            document.getElementById('menu-screen').style.display = 'none';
            document.getElementById('game-screen').style.display = 'block';
            
            generateLevel(currentLevel);
            updateUI();
            gameLoop();
            
            // –ó–∞–ø—É—Å–∫ —Ç–∞–π–º–µ—Ä–∞
            clearInterval(gameTimer);
            gameTimer = setInterval(() => {
                if (gameState === 'playing') {
                    gameTime = Math.floor((Date.now() - startTime) / 1000);
                    updateTimer();
                }
            }, 1000);
        }

        function completeLevel() {
            gameState = 'levelComplete';
            document.getElementById('level-complete').style.display = 'block';
        }

        function nextLevel() {
            if (currentLevel < 5) {
                currentLevel++;
                document.getElementById('level-complete').style.display = 'none';
                generateLevel(currentLevel);
                updateUI();
                gameState = 'playing';
            } else {
                alert('üéâ –ü–û–ó–î–†–ê–í–õ–Ø–ï–ú! –í—ã –ø—Ä–æ—à–ª–∏ –≤—Å–µ —É—Ä–æ–≤–Ω–∏ –õ–∞–±–∏—Ä–∏–Ω—Ç–∞ –¢—å–º—ã!');
                returnToMenu();
            }
        }

        function gameOver() {
            alert('‚ò†Ô∏è –í–∞—Å –ø–æ–≥–ª–æ—Ç–∏–ª–∞ —Ç—å–º–∞... –ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞');
            returnToMenu();
        }

        function returnToMenu() {
            gameState = 'menu';
            clearInterval(gameTimer);
            
            document.getElementById('menu-screen').style.display = 'flex';
            document.getElementById('game-screen').style.display = 'none';
            document.getElementById('level-complete').style.display = 'none';
        }

        // ================= –ú–ï–ù–Æ =================
        function showDifficultyMenu() {
            document.getElementById('difficulty-menu').style.display = 'block';
        }

        function hideDifficultyMenu() {
            document.getElementById('difficulty-menu').style.display = 'none';
        }

        function setDifficulty(level) {
            difficulty = level;
            document.getElementById('difficulty').textContent = difficulty;
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∞–∫—Ç–∏–≤–Ω–æ–π –∫–Ω–æ–ø–∫–∏
            document.querySelectorAll('.difficulty-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.textContent.includes(level)) {
                    btn.classList.add('active');
                }
            });
            
            hideDifficultyMenu();
        }

        function showInstructions() {
            document.getElementById('instructions-screen').style.display = 'block';
        }

        function hideInstructions() {
            document.getElementById('instructions-screen').style.display = 'none';
        }

        // ================= –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø =================
        window.onload = function() {
            updateUI();
            
            // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ä–∞–∑–º–µ—Ä–∞ –æ–∫–Ω–∞
            window.addEventListener('resize', () => {
                if (gameState === 'playing') {
                    draw();
                }
            });
        };

        // –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏–µ —Å–∫—Ä–æ–ª–ª–∞ –Ω–∞ –º–æ–±–∏–ª—å–Ω—ã—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞—Ö
        document.addEventListener('touchmove', (e) => {
            if (e.target === canvas) {
                e.preventDefault();
            }
        }, { passive: false });
    </script>
</body>
</html>
